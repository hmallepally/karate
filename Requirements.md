# **Karate API Test Automation Framework Requirements**

## 1. Overview

The objective of this project is to create a robust, data-driven API test automation framework using Karate. The framework will be built with Gradle, integrated with Jenkins for scheduled test execution, and will feature a highly flexible test data management system using CSV files.

A core component is a Java-based utility to preprocess a `api_schema.yaml` file, making the API's structure readily available throughout the test suite for dynamic payload creation and validation.

## 2. Core Technologies & Tools

* **Testing Framework:** Karate
* **Build & Dependency Management:** Gradle
* **Programming Language (for utilities):** Java
* **CI/CD:** Jenkins
* **Data Formats:** YAML (for API schema), JSON (for payload templates), CSV (for test data)

## 3. Proposed Project Structure

Devin should generate the following directory structure to organize the framework components:

```
├── Jenkinsfile
├── build.gradle
├── src
│   ├── main
│   │   └── java
│   │       └── com
│   │           └── fico
│   │               └── karate
│   │                   └── utils
│   │                       └── YamlSchemaUtils.java
│   └── test
│       ├── java
│       │   └── com
│       │       └── fico
│       │           └── tests
│       │               ├── TestRunner.java
│       │               ├── features
│       │               │   └── plor
│       │               │       ├── plor_api.feature
│       │               │       └── plor_api_template.json
│       │               └── karate-config.js
│       └── resources
│           ├── api_schema.yaml
│           └── testdata
│               └── plor_test_scenarios.csv
└───
```

## 4. Key Components & Implementation Details

### 4.1. Gradle Setup (`build.gradle`)

The `build.gradle` file should be configured with the following:

* **Plugins:** `java` and other necessary plugins for a standard Java project.
* **Dependencies:**
    * `com.intuit.karate:karate-junit5`: For running Karate tests with JUnit 5.
    * `com.fasterxml.jackson.dataformat:jackson-dataformat-yaml`: For parsing the YAML schema file in the Java utility.
    * `com.fasterxml.jackson.core:jackson-databind`: Core Jackson dependency.
* **Test Task:** Configure the `test` task to execute the Karate tests. Ensure it can properly locate the feature files.

### 4.2. Jenkins Integration (`Jenkinsfile`)

A `Jenkinsfile` must be created in the project root to define the CI/CD pipeline.

* **Pipeline Type:** Use a declarative pipeline.
* **Scheduling:** The pipeline must be triggered to run twice daily, at **5:00 AM** and **5:00 PM** Central Time. The cron trigger should be configured as follows:
    ```
    triggers {
        cron('TZ=America/Chicago\n0 5,17 * * *')
    }
    ```
* **Stages:**
    1.  **Checkout:** Check out the source code from the repository.
    2.  **Build:** Execute a clean build using Gradle (`./gradlew clean build`).
    3.  **Test:** Run the Karate tests using the Gradle test command (`./gradlew test`).
    4.  **Reporting:** (Optional but recommended) Configure the pipeline to archive JUnit test reports generated by Karate.

### 4.3. YAML Schema Pre-processing (Java Utility)

A Java utility class must be created to load and parse the `api_schema.yaml` file one time.

* **Class Name:** `com.fico.karate.utils.YamlSchemaUtils`
* **Functionality:**
    * The class should contain a `public static` method, e.g., `loadSchemaAsMap(String filePath)`.
    * This method will read the YAML file from the given path.
    * It will parse the YAML into a Java `Map<String, Object>`.
    * This map should be returned to the caller.
* **Purpose:** This utility will be called from `karate-config.js` to avoid re-reading and re-parsing the schema for every single test, improving performance.

### 4.4. Karate Configuration (`karate-config.js`)

This file is the central point of configuration for the Karate framework.

* **Global Schema Variable:**
    * At startup, this script must invoke the `YamlSchemaUtils.loadSchemaAsMap()` Java method.
    * The resulting map must be stored in a global variable, accessible to all feature files (e.g., `karate.schema`).
* **Base Payload Template:**
    * The script should read a common JSON template file (e.g., `plor_api_template.json`) into a global variable (e.g., `karate.basePayload`). This template should contain the full JSON structure with default or placeholder values.

**Example `karate-config.js` Snippet:**

```
function fn() {
var config = {};

// 1. Load the API schema map from our Java utility
var YamlSchemaUtils = Java.type('com.fico.karate.utils.YamlSchemaUtils');
config.schema = YamlSchemaUtils.loadSchemaAsMap('classpath:api_schema.yaml');

// 2. Load the base JSON payload template
config.basePayload = read('classpath:com/fico/tests/features/plor/plor_api_template.json');

return config;
}
```



### 4.5. Test Data CSV File Structure

The framework must be driven by CSV files. The header convention is critical.

* **Header Format:** Headers must use **dot-notation** to map directly to fields in the JSON payload.
* **Array Handling:** For arrays, the header should use bracket notation with the index (e.g., `applicants[0].firstName`).
* **Request vs. Response:** The same CSV row will contain data for both request generation and response validation.
    * Request columns map directly to the payload (e.g., `application.applicationId`).
    * Response validation columns should be prefixed with `response.` to distinguish them (e.g., `response.creditDecisioning.decisionSummary.decisionCode`).

**Example `plor_test_scenarios.csv`:**

| testCaseName                 | application.applicationId | applicants[0].firstName | applicants[0].lastName | response.creditDecisioning.decisioning.subProductDecisions[0].decisionSummary.automatedDecisionCode | response.creditDecisioning.decisioning.subProductDecisions[0].creditLineAssignment.creditLimitAmount |
| :--------------------------- | :------------------------ | :---------------------- | :--------------------- | :-------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------- |
| HappyPath_LowRisk_Approve    | APP-1001                  | John                    | Doe                    | A                                                                                                   | 15000                                                                                            |
| Decline_HighRisk_Applicant | APP-1002                  | Jane                    | Smith                  | D                                                                                                   | 0                                                                                                |

### 4.6. Feature File Test Logic (`plor_api.feature`)

The feature files will use a `Scenario Outline` to iterate through the rows of the CSV file.

* **Test Flow:**
    1.  A fresh copy of the `basePayload` is created for each test run.
    2.  The framework dynamically sets values in this payload using the data from the current CSV row. Karate's `set` command should be used, leveraging the dot-notation headers.
    3.  The API request is sent.
    4.  The response status code is validated.
    5.  The response body is validated by comparing actual values against the expected values in the `response.` columns of the CSV.

**Example `plor_api.feature` Snippet:**

```
Feature: FICO PLOR API Decisioning

Background:

url 'https://api.fico.com/plor'

def basePayload = karate.basePayload

def schema = karate.schema

Scenario Outline: Process PLOR application and validate decisioning for 

Create a fresh request payload for this test run
def requestPayload = karate.clone(basePayload)

Dynamically set request values from the CSV
set requestPayload.application.applicationId = 

set requestPayload.applicants[0].firstName = 

set requestPayload.applicants[0].lastName = 

Execute the API call
Given path '/v1/transaction'
And request requestPayload
When method post
Then status 200

Validate the response against the CSV
def expectedDecisionCode = 

def expectedCreditLimit = 

match response.creditDecisioning.decisioning.subProductDecisions[0].decisionSummary.automatedDecisionCode == expectedDecisionCode

match response.creditDecisioning.decisioning.subProductDecisions[0].creditLineAssignment.creditLimitAmount == expectedCreditLimit

Examples:
| karate.read('classpath:testdata/plor_test_scenarios.csv') |
```


## 5. Summary of Deliverables

1.  A Gradle project with the specified directory structure.
2.  `build.gradle` with Karate and Jackson dependencies.
3.  `Jenkinsfile` configured for twice-daily runs.
4.  `YamlSchemaUtils.java` for schema pre-processing.
5.  `karate-config.js` to initialize global variables (schema map, base payload).
6.  A sample `plor_api_template.json` file.
7.  A sample `plor_test_scenarios.csv` demonstrating the required header format.
8.  A sample `plor_api.feature` file implementing the data-driven test logic.

